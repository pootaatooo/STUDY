#include <iostream>

using namespace std;

int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    
    int n;
    cin >> n;
    int dp[n+1]; // dp[1001]로 설정해도 되나 어차피 n값에 대한 배열만 생기기 때문에 그냥 효율적인 메모리 사용을 하자.
                 // 복잡한 문제가 아니면 초기값 그대로 사용하지 않는 습관을 들이자.
    dp[0] = 1;  // 0이 아니라 1로 설정해준 이유는 식에 곱셈이 있어서 모든 값이 0으로 나오는 경우가 생기기 때문.  
    dp[1] = 1;
    dp[2] = 3;
    
    for(int i=3;i<=n;i++) {
        dp[i] = dp[i-1] + dp[i-2]*2;
        dp[i] %= 10007;
    }
    
    cout << dp[n];
    
    
}

// 11726번과 다른점은 2x2타일이 추가된 것이다.
dp문제를 풀어보며 느낀점은 우선적으로 규칙을 찾기위해 n이 증가함에 따라 찾을 수 있는 값들의 개수를 약 n=5정도 까지
노가다로 구했다. 그리고 점화식을 찾아서 여러번 돌려봤다.
!!사실 근데 n값 정도는 예제랑 다른 반례들 찾아서 미리 안 다음 점화식을 찾는게 더 효율적일듯 하다.
